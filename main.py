


# Объекты

"""Помните, Python рассматривает всё, что есть в программе, как объекты. Имеется в виду,
в самом общем смысле. Вместо того, чтобы говорить “нечто”, мы говорим “объект”."""


# Пример: Использование переменных и констант

# i = 5
# print(i)
# i += i
# print(i)

# s = '''Это многострочная строка.
# Это вторая её строчка.'''
# print(s)

#  ========================================================================================================================================================

# Оператор if

"""Оператор if используется для проверки условий: если1 условие верно2, выполняется блок
выражений (называемый «if-блок»), иначе3 выполняется другой блок выражений (назы-
ваемый «else-блок»). Блок «else» является необязательным."""

# number = 23
# guess = int(input('Введите целое число : '))

# if guess == number:
#     print('Поздравляю, вы угадали,') # Здесь начинается новый блок
#     print('(хотя и не выиграли никакого приза!)') # Здесь заканчивается новый блок
# elif guess < number:
#     print('Нет, загаданное число немного больше этого.') # Ещё один блок
# # Внутри блока вы можете выполнять всё, что угодно ...
# else:
#     print('Нет, загаданное число немного меньше этого.')
# # чтобы попасть сюда, guess должно быть больше, чем number
# print('Завершено')
# # Это последнее выражение выполняется всегда после выполнения оператора if


#  ========================================================================================================================================================

# Оператор while

"""Оператор while позволяет многократно выполнять блок команд до тех пор, пока выпол-
няется некоторое условие. Это один из так называемых операторов цикла. Он также может
иметь необязательный пункт else."""

# number = 23
# running = True

# while running:
#     guess = int(input('Введите целое число : '))
#     if guess == number:
#         print('Поздравляю, вы угадали.')
#         running = False # это останавливает цикл while
#     elif guess < number:
#         print('Нет, загаданное число немного больше этого')
#     else:
#         print('Нет, загаданное число немного меньше этого.')
# else:
#     print('Цикл while закончен.')
# # Здесь можете выполнить всё что вам ещё нужно
# print('Завершение.')

# ========================================================================================================================================================

# Цикл for

"""Оператор for..in также является оператором цикла, который осуществляет итерацию
по последовательности объектов, т.е. проходит через каждый элемент в последователь-
ности. Мы узнаем больше о последовательностях в дальнейших главах, а пока просто
запомните, что последовательность – это упорядоченный набор элементов."""

# for i in range(1, 5):
#     print(i)
# else:
#     print('Цикл for закончен')

#  ========================================================================================================================================================

# Оператор break

"""Оператор break служит для прерывания7 цикла, т.е. остановки выполнения команд да-
же если условие выполнения цикла ещё не приняло значения False или последователь-
ность элементов не закончилась.
Важно отметить, что если циклы for или while прервать оператором break, соответству-
ющие им блоки else выполняться не будут."""

# while True:
#     s = input('Введите что-нибудь : ')
#     if s == 'выход':
#         break
#     print('Длина строки: ', len(s))
# print('Завершение')


#  ========================================================================================================================================================

# Оператор continue

# Оператор continue используется для указания Python, что необходимо пропустить все
# оставшиеся команды в текущем блоке цикла и продолжить9 со следующей итерации цик-
# ла.
# Заметьте, что оператор continue также работает и с циклом for.

# while True:
#     s = input('Введите что-нибудь : ')
#     if s == 'выход':
#         break
#     if len(s) < 3:
#         print('Слишком мало')
#         continue
#     print('Введённая строка достаточной длины')
#     # Разные другие действия здесь...

#  ========================================================================================================================================================

# Функции

"""Функции – это многократно используемые фрагменты программы. Они позволяют дать
имя определённому блоку команд с тем, чтобы в последствии запускать этот блок по
указанному имени в любом месте программы и сколь угодно много раз. Это называется
вызовом функции. Мы уже использовали много встроенных функций, как то len и range.
Функция – это, пожалуй, наиболее важный строительный блок любой нетривиальной
программы (на любом языке программирования), поэтому в этой главе мы рассмотрим
различные аспекты функций.
Функции определяются при помощи зарезервированного слова def. После этого слова
указывается имя функции, за которым следует пара скобок, в которых можно указать
имена некоторых переменных, и заключительное двоеточие в конце строки. Далее сле-
дует блок команд, составляющих"""

# def sayHello():
#     print('Привет, Мир!') # блок, принадлежащий функции
#     # Конец функции


# sayHello() # вызов функции
# sayHello() # ещё один вызов функции

#  ========================================================================================================================================================

# Параметры функций

"""Функции могут принимать параметры, т.е. некоторые значения, передаваемые функции
для того, чтобы она что-либо сделала с ними. Эти параметры похожи на переменные, за
исключением того, что значение этих переменных указывается при вызове функции, и
во время работы функции им уже присвоены их значения.
Параметры указываются в скобках при объявлении функции и разделяются запятыми.
Аналогично мы передаём значения, когда вызываем функцию. Обратите внимание на
терминологию: имена, указанные в объявлении функции, называются параметрами, то-
гда как значения, которые вы передаёте в функцию при её вызове, – аргументами."""

# def printMax(a, b):
#     if a > b:
#     print(a, 'максимально')
#     elif a == b:
#     print(a, 'равно', b)
#     else:
#     print(b, 'максимально')
#     printMax(3, 4) # прямая передача значений


# x = 5
# y = 7
# printMax(x, y) # передача переменных в качестве аргументов


#  ========================================================================================================================================================

# Локальные переменные

"""При объявлении переменных внутри определения функции, они никоим образом не свя-
заны с другими переменными с таким же именем за пределами функции – т.е. имена
переменных являются локальными в функции. Это называется областью видимости пере-
менной. Область видимости всех переменных ограничена блоком, в котором они объяв-
лены, начиная с точки объявления имени."""

# x = 50
# def func(x):
#     print('x равен', x)
#     x = 2
#     print('Замена локального x на', x)


# func(x)
# print('x по прежнему', x)

# Вывод:
# $ python func_local.py
# x равен 50
# Замена локального x на 2
# x по прежнему 50


#  ========================================================================================================================================================

# Зарезервированное слово «global»

"""Чтобы присвоить некоторое значение переменной, определённой на высшем уровне
программы (т.е. не в какой-либо области видимости, как то функции или классы), необ-
ходимо указать Python, что её имя не локально, а глобально (global). Сделаем это при помо-
щи зарезервированного слова global. Без применения зарезервированного слова global
невозможно присвоить значение переменной, определённой за пределами функции.
Можно использовать уже существующие значения переменных, определённых за пре-
делами функции (при условии, что внутри функции не было объявлено переменной с
таким же именем). Однако, это не приветствуется, и его следует избегать, поскольку че-
ловеку, читающему текст программы, будет непонятно, где находится объявление пере-
менной. Использование зарезервированного слова global достаточно ясно показывает,
что переменная объявлена в самом внешнем блоке."""


# x = 50

# def func():
#     global x
#     print('x равно', x)
#     x = 2
#     print('Заменяем глобальное значение x на', x)


# func()
# print('Значение x составляет', x)

# Вывод:
# $ python func_global.py
# x равно 50
# Заменяем глобальное значение x на 2
# Знчение x составляет 2


#  ========================================================================================================================================================


# Зарезервированное слово «nonlocal»

"""Мы увидели, как получать доступ к переменным в локальной и глобальной области ви-
димости. Есть ещё один тип области видимости, называемый «нелокальной» (nonlocal)
областью видимости, который представляет собой нечто среднее между первыми дву-
мя. Нелокальные области видимости встречаются, когда вы определяете функции внутри
функций.
Поскольку в Python всё является выполнимым кодом, вы можете определять функции где
угодно."""

# def func_outer():
#     x = 2
#     print('x равно', x)
#     def func_inner():
#         nonlocal x
#         x = 5


# func_inner()
# print('Локальное x сменилось на', x)


# func_outer()

# Вывод:
# $ python func_nonlocal.py
# x равно 2
# Локальное x сменилось на 5

#  ========================================================================================================================================================

# Значения аргументов по умолчанию

"""Зачастую часть параметров функций могут быть необязательными, и для них будут ис-
пользоваться некоторые заданные значения по умолчанию, если пользователь не укажет
собственных. Этого можно достичь с помощью значений аргументов по умолчанию. Их
можно указать, добавив к имени параметра в определении функции оператор присваи-
вания (=) с последующим значением.
Обратите внимание, что значение по умолчанию должно быть константой. Или точнее
говоря, оно должно быть неизменным1 – это объясняется подробнее в последующих гла-
вах. А пока запомните это.
1 «immutable» в терминологии Python"""

"""Важно: Значениями по умолчанию могут быть снабжены только параметры, находящи-
еся в конце списка параметров. Таким образом, в списке параметров функции параметр
со значением по умолчанию не может предшествовать параметру без значения по умол-
чанию. Это связано с тем, что значения присваиваются параметрам в соответствии с их
положением. Например, def func(a, b=5) допустимо, а def func(a=5, b) – не допусти-
мо."""

# def say(message, times = 1):
#     print(message * times)


# say('Привет')
# say('Мир', 5)


# Вывод:
# $ python func_default.py
# Привет
# МирМирМирМирМир


# ========================================================================================================================================================

# Ключевые аргументы

"""Если имеется некоторая функция с большим числом параметров, и при её вызове тре-
буется указать только некоторые из них, значения этих параметров могут задаваться по
их имени – это называется ключевые параметры. В этом случае для передачи аргументов
функции используется имя (ключ) вместо позиции (как было до сих пор).
Есть два преимущества такого подхода: во-первых, использование функции становится
легче, поскольку нет необходимости отслеживать порядок аргументов; во-вторых, можно
задавать значения только некоторым избранным аргументам, при условии, что осталь-
ные параметры имеют значения аргумента по умолчанию."""

def func(a, b=5, c=10):
    print('a равно', a, ', b равно', b, ', а c равно', c)


func(3, 7)
func(25, c=24)
func(c=50, a=100)


# Вывод:
# $ python func_key.py
# a равно 3, b равно 7, а c равно 10
# a равно 25, b равно 5, а c равно 24
# a равно 100, b равно 5, а c равно 50


# ========================================================================================================================================================

# Переменное число параметров

"""Иногда бывает нужно определить функцию, способную принимать любое число парамет-
ров. Этого можно достичь при помощи звёздочек (сохраните как total.py):"""


def total(initial=5, *numbers, **keywords):
    count = initial
    for number in numbers:
        count += number
    for key in keywords:
        count += keywords[key]
    return count


print(total(10, 1, 2, 3, vegetables=50, fruits=100))

# Вывод:
# $ python total.py
# 166
# Как это работает:
# Когда мы объявляем параметр со звёздочкой (например, *param), все позици-
# онные аргументы начиная с этой позиции и до конца будут собраны в кортеж
# под именем param.
# Аналогично, когда мы объявляем параметры с двумя звёздочками (**param),
# все ключевые аргументы начиная с этой позиции и до конца будут собраны
# в словарь под именем param.
# Мы изучим кортежи и словари


# # Объявляем функцию total с параметрами initial, *numbers и **keywords.
# def total(initial=5, *numbers, **keywords):
#     # Создаем переменную count и присваиваем ей значение initial (по умолчанию 5).
#     count = initial

#     # Первый цикл: проходим по числам, переданным после initial.
#     for number in numbers:
#         # Увеличиваем значение count на каждое число из numbers.
#         count += number

#     # Второй цикл: проходим по парам ключ-значение в словаре keywords.
#     for key in keywords:
#         # Увеличиваем значение count на значение, связанное с текущим ключом.
#         count += keywords[key]

#     # Возвращаем итоговое значение count.
#     return count

# # Вызываем функцию total с различными аргументами.
# # Первый аргумент (10) идет в параметр initial, остальные числа (1, 2, 3) собираются в кортеж numbers.
# # Ключи и значения (vegetables=50, fruits=100) собираются в словарь keywords.
# # Функция складывает все значения и возвращает их.
# print(total(10, 1, 2, 3, vegetables=50, fruits=100))


# ========================================================================================================================================================

# Только ключевые параметры


"""Если некоторые ключевые параметры должны быть доступны только по ключу, а не как
позиционные аргументы, их можно объявить после параметра со звёздочкой"""

def total(initial=5, *numbers, extra_number):
    count = initial
    for number in numbers:
    count += number
    count += extra_number
    print(count)


total(10, 1, 2, 3, extra_number=50)
total(10, 1, 2, 3)
# Вызовет ошибку, поскольку мы не указали значение
# аргумента по умолчанию для 'extra_number'.

# Вывод:
# $ python keyword_only.py
# 66
# Traceback (most recent call last):
# File "keyword_only.py", line 12, in <module>
# total(10, 1, 2, 3)
# TypeError: total() needs keyword-only argument extra_number

# Как это работает:
# Объявление параметров после параметра со звёздочкой даёт только ключевые
# аргументы. Если для таких аргументов не указано значение по умолчанию, и
# оно не передано при вызове, обращение к функции вызовет ошибку, в чём
# мы только что убедились.
# Обратите внимание на использование +=, который представляет собой сокра-
# щённый оператор, позволяющий вместо x = x + y просто написать x +=
# y.
# Если вам нужны аргументы, передаваемые только по ключу, но не нужен па-
# раметр со звёздочкой, то можно просто указать одну звёздочку без указания
# имени: def total(initial=5, *, extra_number).

# ========================================================================================================================================================

# Оператор «return»

"""Оператор return используется для возврата5 из функции, т.е. для прекращения её работы
и выхода из неё. При этом можно также вернуть некоторое значение из функции."""


# def maximum(x, y):
#     if x > y:
#         return x
#     elif x == y:
#         return 'Числа равны.'
#     else:
#         return y


# print(maximum(2, 3))

# Вывод:
# $ python func_return.py
# 3

"""Обратите внимание, что оператор return без указания возвращаемого значения эквива-
лентен выражению return None. None – это специальный тип данных в Python, обознача-
ющий ничего. К примеру, если значение переменной установлено в None, это означает,
что ей не присвоено никакого значения.
Каждая функция содержит в неявной форме оператор return None в конце, если вы
не указали своего собственного оператора return. В этом можно убедиться, запустив
print(someFunction()), где функция someFunction – это какая-нибудь функция, не име-
ющая оператора return в явном виде. Например:"""

# def someFunction():
#     pass

# Оператор pass используется в Python для обозначения пустого блока команд.

# Примечание: Существует встроенная функция max, в которой уже реализован функци-
# онал «поиск максимума», так что пользуйтесь этой встроенной функцией, где это воз-
# можно.


# ========================================================================================================================================================

# Строки документации

"""Python имеет остроумную особенность, называемую строками документации, обычно
обозначаемую сокращённо docstrings. Это очень важный инструмент, которым вы обяза-
тельно должны пользоваться, поскольку он помогает лучше документировать програм-
му и облегчает её понимание. Поразительно, но строку документации можно получить,
например, из функции, даже во время выполнения программы!"""

# def printMax(x, y):
#     '''Выводит максимальное из двух чисел.
#     Оба значения должны быть целыми числами.'''
#     x = int(x) # конвертируем в целые, если возможно
#     y = int(y)
#     if x > y:
#         print(x, 'наибольшее')
#     else:
#         print(y, 'наибольшее')


# printMax(3, 5)
# print(printMax.__doc__)

# ========================================================================================================================================================

# Модули

"""Существуют разные способы составления модулей, но самый простой – это создать файл
с расширением .py, содержащий функции и переменные.
Другой способ – написать модуль на том языке программирования, на котором написан
сам интерпретатор Python. Например, можно писать модули на языке программирова-
ния C, которые после компиляции могут использоваться стандартным интерпретатором
Python.
Модуль можно импортировать в другую программу, чтобы использовать функции из
него. Точно так же мы используем стандартную библиотеку Python. Сперва посмотрим,
как использовать модули стандартной библиотеки."""

# import sys

# print('Аргументы командной строки:')
#     for i in sys.argv:
#         print(i)

# print('\n\nПеременная PYTHONPATH содержит', sys.path, '\n')


# Вывод:
# $ python3 using_sys.py we are arguments
# Аргументы командной строки:
# using_sys.py
# we
# are
# arguments

# Переменная PYTHONPATH содержит ['', 'C:\\Windows\\system32\\python30.zip',
# 'C:\\Python30\\DLLs', 'C:\\Python30\\lib',
# 'C:\\Python30\\lib\\plat-win', 'C:\\Python30',
# 'C:\\Python30\\lib\\site-packages']


import sys

for i in sys.argv:
    print(i)
